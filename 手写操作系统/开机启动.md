# 开机启动（古老的8086处理器）

* 从按下电源键开始，CPU会重置，把第一条指令的地址初始化为` 0xffff0`（现在32位是`0xfffffff0`）（具体实际上是把cs段寄存器初始化为` 0xf000` ,偏移地址寄存器设置为` 0xfff0`,所以真实物理地址就是段寄存器左移四位+偏移就是` 0xffff0`）

*  。 而内存中的地址一部分会映射到外设上，比如一部分映射到显存，一部分映射给硬盘控制器等等。而BIOS的空间会被映射到` 0xc0000`-` 0xfffff`的位置，同时BIOS的程序还占用了内存中开头的一些位置，把中断向量表写在内存开始的一些地方。其中系统BIOS占用了` 0xf0000`-` 0xfffff` 的空间。

* 又因为第一条指令的地址为` 0xffff0`，所以从` 0xffff0`-` 0xfffff`只有16字节的空间代码，但是这个代码肯定不够写，所以这里是一条跳转地址

  ```
  jmp far f000:e05b//意思是跳转到物理地址0xfe05b去运行
  ```

* 地址` 0xfe05b` 部分的代码会检测一些外设的信息，并初始化好硬件，建立中断向量表并填写中断例程，实际上这部分就是写死的。然后最后就是加载启动区。那么何为BIOS启动区。

* BIOS里面就有一张启动设备表，BIOS会按照这 个表里面列出的顺序查找可启动设备。那么怎么知道该设备是否可以启动呢？规则其实很 简单：如果这个存储设备的第一个扇区中512个字节20的最后两个字节是0x55和0xAA，那么 该存储设备就是可启动的。这是一个约定，所以BIOS会对这个列表中的设备逐一检测，只 要有一个设备满足要求，后续的设备将不再测试。 当BIOS找到可启动的设备后，便将该设备的第一个扇区加载到内存的0x7C00地址处， 并且跳转过去执行。（通过in/out指令来把设备中的内容复制到内存）（这个0x7c00是BIOS开发团队设定的），而这段512字节的代码就是所谓的bootloader程序。（早期BIOS团队假设操作系统需要最小内存为32KB，但是又想仅仅留512字节不太好，再多保留一些栈数据，就保留了1KB字节（0x400），所以0x7c00+0x400=0x8000刚好是32KB.

  ```
  
  ; hello-os
  ; TAB=4
  
    ORG  0x7c00   ;程序加载到内存的 0x7c00 这个位置
  
  ;程序主体
  
  entry:
    MOV  AX,0   ;初始化寄存器
    MOV  SS,AX
    MOV  SP,0x7c00
    MOV  DS,AX   ;段寄存器初始化为 0
    MOV  ES,AX
    MOV  SI,msg
  putloop:
    MOV  AL,[SI]
    ADD  SI,1
    CMP  AL,0   ;如果遇到 0 结尾的，就跳出循环不再打印新字符
    JE  fin
    MOV  AH,0x0e   ;指定文字
    MOV  BX,15   ;指定颜色
    INT  0x10   ;调用 BIOS 显示字符函数
    JMP  putloop
  fin:
    HLT
    JMP  fin
  msg:
    DB  0x0a,0x0a  ;换行、换行
    DB  "hello-os"
    DB  0x0a   ;换行
    DB  0    ;0 结尾
  
    RESB 0x7dfe-$   ;填充0到512字节
    DB 0x55, 0xaa   ;可启动设备标识
  ```

  

* 然后启动区中的代码任务主要是加载操作系统，并跳转到操作系统加载处。（）

* ![](开机启动.assets\bios内存空间.jpg)