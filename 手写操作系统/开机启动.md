# 开机启动（古老的8086处理器）

* 从按下电源键开始，CPU会重置，把第一条指令的地址初始化为` 0xffff0`（现在32位是`0xfffffff0`）（具体实际上是把cs段寄存器初始化为` 0xf000` ,偏移地址寄存器设置为` 0xfff0`,所以真实物理地址就是段寄存器左移四位+偏移就是` 0xffff0`）

*  。 而内存中的地址一部分会映射到外设上，比如一部分映射到显存，一部分映射给硬盘控制器等等。而BIOS的空间会被映射到` 0xc0000`-` 0xfffff`的位置，同时BIOS的程序还占用了内存中开头的一些位置，把中断向量表写在内存开始的一些地方。其中系统BIOS占用了` 0xf0000`-` 0xfffff` 的空间。

* 又因为第一条指令的地址为` 0xffff0`，所以从` 0xffff0`-` 0xfffff`只有16字节的空间代码，但是这个代码肯定不够写，所以这里是一条跳转地址

  ```
  jmp far f000:e05b//意思是跳转到物理地址0xfe05b去运行
  ```

* 地址` 0xfe05b` 部分的代码会检测一些外设的信息，并初始化好硬件，建立中断向量表并填写中断例程，实际上这部分就是写死的。然后最后就是加载启动区。那么何为BIOS启动区。

* BIOS里面就有一张启动设备表，BIOS会按照这 个表里面列出的顺序查找可启动设备。那么怎么知道该设备是否可以启动呢？规则其实很 简单：如果这个存储设备的第一个扇区中512个字节20的最后两个字节是0x55和0xAA，那么 该存储设备就是可启动的。这是一个约定，所以BIOS会对这个列表中的设备逐一检测，只 要有一个设备满足要求，后续的设备将不再测试。 当BIOS找到可启动的设备后，便将该设备的第一个扇区加载到内存的0x7C00地址处， 并且跳转过去执行。（通过in/out指令来把设备中的内容复制到内存）（这个0x7c00是BIOS开发团队设定的），而这段512字节的代码就是所谓的bootloader程序。（早期BIOS团队假设操作系统需要最小内存为32KB，但是又想仅仅留512字节不太好，再多保留一些栈数据，就保留了1KB字节（0x400），所以0x7c00+0x400=0x8000刚好是32KB.

  ```asm
  ; hello-os
  ; TAB=4
  
    ORG  0x7c00   ;程序加载到内存的 0x7c00 这个位置
  
  ;程序主体
  
  entry:
    MOV  AX,0   ;初始化寄存器
    MOV  SS,AX
    MOV  SP,0x7c00
    MOV  DS,AX   ;段寄存器初始化为 0
    MOV  ES,AX
    MOV  SI,msg
  putloop:
    MOV  AL,[SI]
    ADD  SI,1
    CMP  AL,0   ;如果遇到 0 结尾的，就跳出循环不再打印新字符
    JE  fin
    MOV  AH,0x0e   ;指定文字
    MOV  BX,15   ;指定颜色
    INT  0x10   ;调用 BIOS 显示字符函数
    JMP  putloop
  fin:
    HLT
    JMP  fin
  msg:
    DB  0x0a,0x0a  ;换行、换行
    DB  "hello-os"
    DB  0x0a   ;换行
    DB  0    ;0 结尾
  
    RESB 0x7dfe-$   ;填充0到512字节
    DB 0x55, 0xaa   ;可启动设备标识
  ```

* 然后启动区中的代码任务主要是加载操作系统，并跳转到操作系统加载处。（上面的bios并没有说明函数的入口，另一版本的boot.s在源代码中）
![](./开机启动.assets/bios内存空间.jpg)



# 字符显示

* 我们知道，对于一个字符的编码通常有输入码、内码和字模码三种。其中字模码定义了 一个字符在屏幕上显示的点阵坐标。通常显卡内置一套关于基本英文字符的显示是很容易 做到的，而内置汉字的显示就较为麻烦。在这篇文档中我们只使用显卡的文本模式，不会 涉及到图形模式的内容。因为一旦使用了图形模式的内容，我们就需要自行定义字符的字 模码了，这很繁琐而且对我们理解操作系统原理的意义不是很大。所以我们只使用显卡的 文本模式进行屏幕显示控制。所有在PC上工作的显卡，在加电初始化之后都会自动初始化 到80*25的文本模式。在这个模式下，屏幕被划分为25行，每行可以显示80个字符，所以 一屏可以显示2000个字符。上图中的0xB8000～0xBFFFF这个地址段便是映射到文本模式的 显存的。当访问这些地址的时候，实际上读写的是显存区域，而显卡会周期性的读取这里 的数据，并且把它们按顺序显示在屏幕上。 那么，按照什么规则显示呢？这就要谈到内码了。内码定义了字符在内存中存储的形 式，而英文编码就是大家所熟知的ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）码了。对应的关系很简单，从0xB8000这个地址开 始，每2个字节表示屏幕上显示的一个字符。从屏幕的第一行开始对应，一行接着一行的对 应下去。而这两个字节的前一个是显示字符的ASCII码，后一个是控制这个字符颜色和属性 的控制信息，这个字节的8个bit位表示不同的含义。每一位的含义如图所示

![image-20201224112514910](./%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/image-20201224112514910.png)

* 理解了显卡文本模式的原理之后接下来就是对屏幕显示控制编码了。不过显卡除了显 示内容的存储单元之外，还有部分的显示控制单元需要了解。这些显示控制单元被编制在 了独立的I/O空间里，需要用特殊的in/out指令去读写。这里相关的控制寄存器多达300多 个，显然无法一一映射到I/O端口的地址空间。对此工程师们解决方案是，将一个端口作为 内部寄存器的索引：0x3D4，再通过0x3D5端口来设置相应寄存器的值。
![image-20201224112729733](./%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/image-20201224112729733.png)

# Debug  printk 和可变参数

* 因为系统底层没有stdin和stdout这种，所以可以通过之前写的screen_write()函数往屏幕上打印字符，但是这里要用到可变参数，即类似printf的可变参数形式。

* ` void printk(const char *format, ...);` 可变参数是通过gcc编译器中内置的va_list来实现的，一些地方也把它定义成宏。

  ```c++
  #define va_list char *
  #define va_start(p, first) (p = (va_list)&first + sizeof(first))//将指针p变成可变参数的第一个参数地址
  #define va_arg(p, next) (*(next*)((p += sizeof(next) ) − sizeof(next)))//将指针p指向下一个参数地址，并返回当前参数的值
  #define va_end(p) (p = (va_list)NULL)//将p定义为NULL
  //调用
  va_start(args,format);
  ```

  

## x86-64函数调用栈和寄存器传递参数

* 以下是64位环境下的，32位环境下所有参数都是通过栈来传递的。

* 在内存中，栈是向下增长的。假设我们写了这么一段程序，

  ```c++
  struct st
  {
          int a;
          int b;
          double c;
  };
  void f(st x,int x1,int x2,int x3,int x4,int x5,int x6,int x7,int x8)
  {
  
  }
  int main()
  {
          int i=1;
          int j=2;
          int k=3;
          st x;
          x.a=1;
          x.b=2;
          x.c=3.0;
          f(x,i,j,k,4,5,6,7,8);
          return 0;
  }
  ```

*  main函数栈帧如下![](%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/%E6%A0%88.jpg)

*  **这里有一个细节，如果被调用的函数是最后一次调用的函数，他的最后一个函数栈帧rsp和rbp是同一个位置，但是还是可以使用rbp以下的空间。**

* 其中栈中数字6，7，8虽然在main函数的栈帧中，但是属于f函数栈帧中可以访问的内容，因为他是参数传递过去的临时变量。

  

* 部分汇编代码如下

  ![image-20201224142822407](%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/image-20201224142822407.png)

## 可变参数传递

由于是可变参数，所以所有参数都是在栈上的，通过va_list即可调取参数列表。这些都是gcc编译器内置的变量和函数，或者也可以把他们定义成如下的宏，va_list为参数的起始地址。

```c++
#define va_list char *

#define va_start(p, first) (p = (va_list)&first + sizeof(first))
#define va_arg(p, next) (*(next*)((p += sizeof(next) ) − sizeof(next)))
#define va_end(p) (p = (va_list)NULL)
```

## printk

* 类似于printf，printk通过调用vsprintf来输出格式化的字符串。
* vsprintf通过三个方面来输出，一个是输出串的位宽，一个是小数的精度（内核中没有浮点数的计算，所以这里用不到），一个是输出的是什么类型的字符，整形、字符串、8进制、16进制等等。
* 具体见代码printk.c

# 代码级调试

## 打印函数调用栈

```asm
; ----------------------------------------------------------------
;
; 	boot.s -- 内核从这里开始
;
;                 这里还有根据 GRUB Multiboot 规范的一些定义
;
; ----------------------------------------------------------------

MBOOT_HEADER_MAGIC 	equ 	0x1BADB002 	; Multiboot 魔数，由规范决定的

MBOOT_PAGE_ALIGN 	equ 	1 << 0    	; 0 号位表示所有的引导模块将按页(4KB)边界对齐
MBOOT_MEM_INFO 		equ 	1 << 1    	; 1 号位通过 Multiboot 信息结构的 mem_* 域包括可用内存的信息
						; (告诉GRUB把内存空间的信息包含在Multiboot信息结构中)

; 定义我们使用的 Multiboot 的标记
MBOOT_HEADER_FLAGS 	equ 	MBOOT_PAGE_ALIGN | MBOOT_MEM_INFO

; 域checksum是一个32位的无符号值，当与其他的magic域(也就是magic和flags)相加时，
; 要求其结果必须是32位的无符号值 0 (即magic + flags + checksum = 0)
MBOOT_CHECKSUM 		equ 	- (MBOOT_HEADER_MAGIC + MBOOT_HEADER_FLAGS)

; 符合Multiboot规范的 OS 映象需要这样一个 magic Multiboot 头

; Multiboot 头的分布必须如下表所示：
; ----------------------------------------------------------
; 偏移量  类型  域名        备注
;
;   0     u32   magic       必需
;   4     u32   flags       必需 
;   8     u32   checksum    必需 
;
; 我们只使用到这些就够了，更多的详细说明请参阅 GNU 相关文档
;-----------------------------------------------------------

;-----------------------------------------------------------------------------

[BITS 32]  	; 所有代码以 32-bit 的方式编译

section .text 	; 代码段从这里开始

; 在代码段的起始位置设置符合 Multiboot 规范的标记

dd MBOOT_HEADER_MAGIC 	; GRUB 会通过这个魔数判断该映像是否支持
dd MBOOT_HEADER_FLAGS   ; GRUB 的一些加载时选项，其详细注释在定义处
dd MBOOT_CHECKSUM       ; 检测数值，其含义在定义处

[GLOBAL start] 		; 内核代码入口，此处提供该声明给 ld 链接器
[GLOBAL glb_mboot_ptr] 	; 全局的 struct multiboot * 变量
[EXTERN kern_entry] 	; 声明内核 C 代码的入口函数

start:
	cli  			 ; 此时还没有设置好保护模式的中断处理，要关闭中断
				 ; 所以必须关闭中断
	mov esp, STACK_TOP  	 ; 设置内核栈地址
	mov ebp, 0 		 ; 帧指针修改为 0
	and esp, 0FFFFFFF0H	 ; 栈地址按照16字节对齐
	mov [glb_mboot_ptr], ebx ; 将 ebx 中存储的指针存入全局变量
	call kern_entry		 ; 调用内核入口函数
stop:
	hlt 			 ; 停机命令，什么也不做，可以降低 CPU 功耗
	jmp stop 		 ; 到这里结束，关机什么的后面再说

;-----------------------------------------------------------------------------

section .bss 			 ; 未初始化的数据段从这里开始
stack:
	resb 32768 	 	 ; 这里作为内核栈
glb_mboot_ptr: 			 ; 全局的 multiboot 结构体指针
	resb 4

STACK_TOP equ $-stack-1 	 ; 内核栈顶，$ 符指代是当前地址

;-----------------------------------------------------------------------------
```

1. 初始定义

   ```asm
   MBOOT_HEADER_MAGIC 	equ 	0x1BADB002 	;
   MBOOT_PAGE_ALIGN 	equ 	1 << 0    	; 
   MBOOT_MEM_INFO 		equ 	1 << 1    	;  
   MBOOT_HEADER_FLAGS 	equ 	MBOOT_PAGE_ALIGN | MBOOT_MEM_INFO
   MBOOT_CHECKSUM 		equ 	- (MBOOT_HEADER_MAGIC + MBOOT_HEADER_FLAGS)
   ```

   - MBOOT_HEADER_MAGIC：multiboot规范规定；
   - MBOOT_PAGE_ALIGN：`equ`为等于，`1<<0`相当于0001；
   - MBOOT_MEM_INFO：`1<<1`相当于0010；
   - MBOOT_HEADER_FLAGS：`|`为or处理，得：0011；
   - MBOOT_CHECKSUM：规范要求三者和为0。

2. start

   START 表示进程段的开始，END START就是结束。
   不过START不是关键词，它是一个标识可以用户自己随意使用，不过不能用保留字，关键词，一般还有用main的。用法一样，首先main，结束end main。一般编程一定要有

3. `call kern_entry`

   调用kern_entry，进入C函数内核；

4. 栈

   ```
   stack:
   	resb 32768 	 	 ; resb预留空间，单位为字节，这里是2^15，32KB的空间
   glb_mboot_ptr: 			 ; 全局的 multiboot 结构体指针
   	resb 4
   STACK_TOP equ $-stack-1 ;$表示当前栈针地址
   ```

   RESB命令是“reserve byte”的略写预约字节。

   栈是上低下高，由高向低生长，所以`ebp`是栈基，在最高位，减去stack，也就是预留了内核的栈空间，所以`STACK_TOP`在最低位，在上面。

5. `eax`

    必须包含魔数 0x2BADB002；这个值指出操作系统是被一个符合 Multiboot 规范的引导进程载入的。

6. `ebx`

   必须包含由引导进程提供的 Multiboot 信息结构的物理地址。 按照协议，GRUB把一些计算机硬件和我们内核文档相关的信息放在了一个结构体中，并且将这个结构体指针放在了ebx寄存器中。