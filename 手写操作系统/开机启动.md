# 开机启动（古老的8086处理器）

* 从按下电源键开始，CPU会重置，把第一条指令的地址初始化为` 0xffff0`（现在32位是`0xfffffff0`）（具体实际上是把cs段寄存器初始化为` 0xf000` ,偏移地址寄存器设置为` 0xfff0`,所以真实物理地址就是段寄存器左移四位+偏移就是` 0xffff0`）

*  。 而内存中的地址一部分会映射到外设上，比如一部分映射到显存，一部分映射给硬盘控制器等等。而BIOS的空间会被映射到` 0xc0000`-` 0xfffff`的位置，同时BIOS的程序还占用了内存中开头的一些位置，把中断向量表写在内存开始的一些地方。其中系统BIOS占用了` 0xf0000`-` 0xfffff` 的空间。

* 又因为第一条指令的地址为` 0xffff0`，所以从` 0xffff0`-` 0xfffff`只有16字节的空间代码，但是这个代码肯定不够写，所以这里是一条跳转地址

  ```
  jmp far f000:e05b//意思是跳转到物理地址0xfe05b去运行
  ```

* 地址` 0xfe05b` 部分的代码会检测一些外设的信息，并初始化好硬件，建立中断向量表并填写中断例程，实际上这部分就是写死的。然后最后就是加载启动区。那么何为BIOS启动区。

* BIOS里面就有一张启动设备表，BIOS会按照这 个表里面列出的顺序查找可启动设备。那么怎么知道该设备是否可以启动呢？规则其实很 简单：如果这个存储设备的第一个扇区中512个字节20的最后两个字节是0x55和0xAA，那么 该存储设备就是可启动的。这是一个约定，所以BIOS会对这个列表中的设备逐一检测，只 要有一个设备满足要求，后续的设备将不再测试。 当BIOS找到可启动的设备后，便将该设备的第一个扇区加载到内存的0x7C00地址处， 并且跳转过去执行。（通过in/out指令来把设备中的内容复制到内存）（这个0x7c00是BIOS开发团队设定的），而这段512字节的代码就是所谓的bootloader程序。（早期BIOS团队假设操作系统需要最小内存为32KB，但是又想仅仅留512字节不太好，再多保留一些栈数据，就保留了1KB字节（0x400），所以0x7c00+0x400=0x8000刚好是32KB.

  ```asm
  ; hello-os
  ; TAB=4
  
    ORG  0x7c00   ;程序加载到内存的 0x7c00 这个位置
  
  ;程序主体
  
  entry:
    MOV  AX,0   ;初始化寄存器
    MOV  SS,AX
    MOV  SP,0x7c00
    MOV  DS,AX   ;段寄存器初始化为 0
    MOV  ES,AX
    MOV  SI,msg
  putloop:
    MOV  AL,[SI]
    ADD  SI,1
    CMP  AL,0   ;如果遇到 0 结尾的，就跳出循环不再打印新字符
    JE  fin
    MOV  AH,0x0e   ;指定文字
    MOV  BX,15   ;指定颜色
    INT  0x10   ;调用 BIOS 显示字符函数
    JMP  putloop
  fin:
    HLT
    JMP  fin
  msg:
    DB  0x0a,0x0a  ;换行、换行
    DB  "hello-os"
    DB  0x0a   ;换行
    DB  0    ;0 结尾
  
    RESB 0x7dfe-$   ;填充0到512字节
    DB 0x55, 0xaa   ;可启动设备标识
  ```

* 然后启动区中的代码任务主要是加载操作系统，并跳转到操作系统加载处。（上面的bios并没有说明函数的入口，另一版本的boot.s在源代码中）
![](./开机启动.assets/bios内存空间.jpg)



# 字符显示

* 我们知道，对于一个字符的编码通常有输入码、内码和字模码三种。其中字模码定义了 一个字符在屏幕上显示的点阵坐标。通常显卡内置一套关于基本英文字符的显示是很容易 做到的，而内置汉字的显示就较为麻烦。在这篇文档中我们只使用显卡的文本模式，不会 涉及到图形模式的内容。因为一旦使用了图形模式的内容，我们就需要自行定义字符的字 模码了，这很繁琐而且对我们理解操作系统原理的意义不是很大。所以我们只使用显卡的 文本模式进行屏幕显示控制。所有在PC上工作的显卡，在加电初始化之后都会自动初始化 到80*25的文本模式。在这个模式下，屏幕被划分为25行，每行可以显示80个字符，所以 一屏可以显示2000个字符。上图中的0xB8000～0xBFFFF这个地址段便是映射到文本模式的 显存的。当访问这些地址的时候，实际上读写的是显存区域，而显卡会周期性的读取这里 的数据，并且把它们按顺序显示在屏幕上。 那么，按照什么规则显示呢？这就要谈到内码了。内码定义了字符在内存中存储的形 式，而英文编码就是大家所熟知的ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）码了。对应的关系很简单，从0xB8000这个地址开 始，每2个字节表示屏幕上显示的一个字符。从屏幕的第一行开始对应，一行接着一行的对 应下去。而这两个字节的前一个是显示字符的ASCII码，后一个是控制这个字符颜色和属性 的控制信息，这个字节的8个bit位表示不同的含义。每一位的含义如图所示

![image-20201224112514910](./%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/image-20201224112514910.png)

* 理解了显卡文本模式的原理之后接下来就是对屏幕显示控制编码了。不过显卡除了显 示内容的存储单元之外，还有部分的显示控制单元需要了解。这些显示控制单元被编制在 了独立的I/O空间里，需要用特殊的in/out指令去读写。这里相关的控制寄存器多达300多 个，显然无法一一映射到I/O端口的地址空间。对此工程师们解决方案是，将一个端口作为 内部寄存器的索引：0x3D4，再通过0x3D5端口来设置相应寄存器的值。
![image-20201224112729733](./%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/image-20201224112729733.png)

# Debug  printk 和可变参数

* 因为系统底层没有stdin和stdout这种，所以可以通过之前写的screen_write()函数往屏幕上打印字符，但是这里要用到可变参数，即类似printf的可变参数形式。

* ` void printk(const char *format, ...);` 可变参数是通过gcc编译器中内置的va_list来实现的，一些地方也把它定义成宏。

  ```c++
  #define va_list char *
  #define va_start(p, first) (p = (va_list)&first + sizeof(first))//将指针p变成可变参数的第一个参数地址
  #define va_arg(p, next) (*(next*)((p += sizeof(next) ) − sizeof(next)))//将指针p指向下一个参数地址，并返回当前参数的值
  #define va_end(p) (p = (va_list)NULL)//将p定义为NULL
  //调用
  va_start(args,format);
  ```

  

## x86-64函数调用栈和寄存器传递参数

* 以下是64位环境下的，32位环境下所有参数都是通过栈来传递的。

* 在内存中，栈是向下增长的。假设我们写了这么一段程序，

  ```c++
  struct st
  {
          int a;
          int b;
          double c;
  };
  void f(st x,int x1,int x2,int x3,int x4,int x5,int x6,int x7,int x8)
  {
  
  }
  int main()
  {
          int i=1;
          int j=2;
          int k=3;
          st x;
          x.a=1;
          x.b=2;
          x.c=3.0;
          f(x,i,j,k,4,5,6,7,8);
          return 0;
  }
  ```

*  main函数栈帧如下![](%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/%E6%A0%88.jpg)

*  **这里有一个细节，如果被调用的函数是最后一次调用的函数，他的最后一个函数栈帧rsp和rbp是同一个位置，但是还是可以使用rbp以下的空间。**

* 其中栈中数字6，7，8虽然在main函数的栈帧中，但是属于f函数栈帧中可以访问的内容，因为他是参数传递过去的临时变量。

  

* 部分汇编代码如下

  ![image-20201224142822407](%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/image-20201224142822407.png)

## 可变参数传递

由于是可变参数，所以所有参数都是在栈上的，通过va_list即可调取参数列表。这些都是gcc编译器内置的变量和函数，或者也可以把他们定义成如下的宏，va_list为参数的起始地址。

```c++
#define va_list char *

#define va_start(p, first) (p = (va_list)&first + sizeof(first))
#define va_arg(p, next) (*(next*)((p += sizeof(next) ) − sizeof(next)))
#define va_end(p) (p = (va_list)NULL)
```

## printk

* 类似于printf，printk通过调用vsprintf来输出格式化的字符串。
* vsprintf通过三个方面来输出，一个是输出串的位宽，一个是小数的精度（内核中没有浮点数的计算，所以这里用不到），一个是输出的是什么类型的字符，整形、字符串、8进制、16进制等等。
* 具体见代码printk.c

# 代码级调试

## 打印函数调用栈

```asm
; ----------------------------------------------------------------
;
; 	boot.s -- 内核从这里开始
;
;                 这里还有根据 GRUB Multiboot 规范的一些定义
;
; ----------------------------------------------------------------

MBOOT_HEADER_MAGIC 	equ 	0x1BADB002 	; Multiboot 魔数，由规范决定的

MBOOT_PAGE_ALIGN 	equ 	1 << 0    	; 0 号位表示所有的引导模块将按页(4KB)边界对齐
MBOOT_MEM_INFO 		equ 	1 << 1    	; 1 号位通过 Multiboot 信息结构的 mem_* 域包括可用内存的信息
						; (告诉GRUB把内存空间的信息包含在Multiboot信息结构中)

; 定义我们使用的 Multiboot 的标记
MBOOT_HEADER_FLAGS 	equ 	MBOOT_PAGE_ALIGN | MBOOT_MEM_INFO

; 域checksum是一个32位的无符号值，当与其他的magic域(也就是magic和flags)相加时，
; 要求其结果必须是32位的无符号值 0 (即magic + flags + checksum = 0)
MBOOT_CHECKSUM 		equ 	- (MBOOT_HEADER_MAGIC + MBOOT_HEADER_FLAGS)

; 符合Multiboot规范的 OS 映象需要这样一个 magic Multiboot 头

; Multiboot 头的分布必须如下表所示：
; ----------------------------------------------------------
; 偏移量  类型  域名        备注
;
;   0     u32   magic       必需
;   4     u32   flags       必需 
;   8     u32   checksum    必需 
;
; 我们只使用到这些就够了，更多的详细说明请参阅 GNU 相关文档
;-----------------------------------------------------------

;-----------------------------------------------------------------------------

[BITS 32]  	; 所有代码以 32-bit 的方式编译

section .text 	; 代码段从这里开始

; 在代码段的起始位置设置符合 Multiboot 规范的标记

dd MBOOT_HEADER_MAGIC 	; GRUB 会通过这个魔数判断该映像是否支持
dd MBOOT_HEADER_FLAGS   ; GRUB 的一些加载时选项，其详细注释在定义处
dd MBOOT_CHECKSUM       ; 检测数值，其含义在定义处

[GLOBAL start] 		; 内核代码入口，此处提供该声明给 ld 链接器
[GLOBAL glb_mboot_ptr] 	; 全局的 struct multiboot * 变量
[EXTERN kern_entry] 	; 声明内核 C 代码的入口函数

start:
	cli  			 ; 此时还没有设置好保护模式的中断处理，要关闭中断
				 ; 所以必须关闭中断
	mov esp, STACK_TOP  	 ; 设置内核栈地址
	mov ebp, 0 		 ; 帧指针修改为 0
	and esp, 0FFFFFFF0H	 ; 栈地址按照16字节对齐
	mov [glb_mboot_ptr], ebx ; 将 ebx 中存储的指针存入全局变量
	call kern_entry		 ; 调用内核入口函数
stop:
	hlt 			 ; 停机命令，什么也不做，可以降低 CPU 功耗
	jmp stop 		 ; 到这里结束，关机什么的后面再说

;-----------------------------------------------------------------------------

section .bss 			 ; 未初始化的数据段从这里开始
stack:
	resb 32768 	 	 ; 这里作为内核栈
glb_mboot_ptr: 			 ; 全局的 multiboot 结构体指针
	resb 4

STACK_TOP equ $-stack-1 	 ; 内核栈顶，$ 符指代是当前地址

;-----------------------------------------------------------------------------
```

1. 初始定义

   ```asm
   MBOOT_HEADER_MAGIC 	equ 	0x1BADB002 	;
   MBOOT_PAGE_ALIGN 	equ 	1 << 0    	; 
   MBOOT_MEM_INFO 		equ 	1 << 1    	;  
   MBOOT_HEADER_FLAGS 	equ 	MBOOT_PAGE_ALIGN | MBOOT_MEM_INFO
   MBOOT_CHECKSUM 		equ 	- (MBOOT_HEADER_MAGIC + MBOOT_HEADER_FLAGS)
   ```

   - MBOOT_HEADER_MAGIC：multiboot规范规定；
   - MBOOT_PAGE_ALIGN：`equ`为等于，`1<<0`相当于0001；
   - MBOOT_MEM_INFO：`1<<1`相当于0010；
   - MBOOT_HEADER_FLAGS：`|`为or处理，得：0011；
   - MBOOT_CHECKSUM：规范要求三者和为0。

2. start

   START 表示进程段的开始，END START就是结束。
   不过START不是关键词，它是一个标识可以用户自己随意使用，不过不能用保留字，关键词，一般还有用main的。用法一样，首先main，结束end main。一般编程一定要有

3. `call kern_entry`

   调用kern_entry，进入C函数内核；

4. 栈

   ```
   stack:
   	resb 32768 	 	 ; resb预留空间，单位为字节，这里是2^15，32KB的空间
   glb_mboot_ptr: 			 ; 全局的 multiboot 结构体指针
   	resb 4
   STACK_TOP equ $-stack-1 ;$表示当前栈针地址
   ```

   RESB命令是“reserve byte”的略写预约字节。

   栈是上低下高，由高向低生长，所以`ebp`是栈基，在最高位，减去stack，也就是预留了内核的栈空间，所以`STACK_TOP`在最低位，在上面。

5. `eax`

    必须包含魔数 0x2BADB002；这个值指出操作系统是被一个符合 Multiboot 规范的引导进程载入的。

6. `ebx`

   必须包含由引导进程提供的 Multiboot 信息结构的物理地址。 按照协议，GRUB把一些计算机硬件和我们内核文档相关的信息放在了一个结构体中，并且将这个结构体指针放在了ebx寄存器中。

## hx_kernel反汇编以及打印函数调用栈

* 关键代码：

```asm
0010000c <start>:
  10000c:	fa                   	cli    ;关中断
  10000d:	bc 03 80 00 00       	mov    esp,0x8003;初始化内核栈顶指针
  100012:	bd 00 00 00 00       	mov    ebp,0x0;初始化内核栈底指针
  100017:	83 e4 f0             	and    esp,0xfffffff0;保证栈顶指针16字节对齐
  10001a:	89 1d 00 b0 10 00    	mov    DWORD PTR ds:0x10b000,ebx;把ebx寄存器中存储的multiboot_t结构体指针传递给全局变量glb_mboot_ptr
  100020:	e8 e7 07 00 00       	call   10080c <kern_entry>;实际做了push 返回地址，然后jmp 10080c跳转到kern_entry函数入口

00100025 <stop>:
  100025:	f4                   	hlt    
  100026:	eb fd                	jmp    100025 <stop>
```

* 打印函数调用栈是通过出错时候，获取当前函数的ebp寄存器中的值，即可知道当前栈帧的栈底，通过栈底指针指向的地址可以知道上一函数的栈底ebp，栈底指针+1可知本函数返回地址的下一条指令地址，然后可以通过指令地址，到elf结构体中去查找当前指令所在函数名。

# 80386下的保护模式

* 我们知道，对CPU来讲，系统中的所有储存器中的储存单元都处于一个统一的逻辑储存 器中，它的容量受CPU寻址能力的限制。这个逻辑储存器就是我们所说的线性地址空间。 8086有20位地址线，拥有1MB的线性地址空间。而80386有32位地址线，拥有4GB的线性地 址空间。但是80386依旧保留了8086采用的地址分段的方式，只是增加了一个折中的方案， 即只分一个段，段基址0×00000000，段长0xFFFFFFFF（4GB），这样的话整个线性空间可 以看作就一个段，这就是所谓的平坦模型（Flat Mode）。
* 考虑到各种属性和需要设置的操作，32位保护模 式下对一个内存段的描述需要8个字节，其称之为段描述符（Segment Descriptor）。段 描述符分为数据段描述符、指令段描述符和系统段描述符三种。
* 参考（https://blog.csdn.net/me1171115772/article/details/51750442）
* ![image-20201228221323999](%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/image-20201228221323999.png)

![image-20201229224929656](%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/image-20201229224929656.png)

![image-20201229225937193](%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/image-20201229225937193.png)



* 因为有很多段，所以这些段被放在内存中，通过段描述符表来管理。在很多的段描述符表中，最重要的就是全局段描述符表，也就是所谓的` GDT`表（Global Descriptor Table，GDT），它为整个软硬件系统服务。这个段描述符表的的地址被放在一个专门的寄存器中，即` GDTR`寄存器，这个寄存器是一个48位的寄存器。这个寄存器0-15位表示GDT的边界位置（数值为表的长度-1，因为从0计算），16-47 位这32位存放的就是GDT的基地址（恰似数组的首地址）。![image-20201228221916429](%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/image-20201228221916429.png)



* 其实80386CPU从加电开始，就自动进入了实模式，此时并不是保护模式。那怎么进入保护模式呢？说来也简单， 80386CPU内部有5个32位的控制寄存器（Control Register，CR），分别是CR0到CR3， 以及CR8。用来表示CPU的一些状态，其中的CR0寄存器的PE位（Protection Enable，保 护模式允许位），0号位，就表示了CPU的运行状态，0为实模式，1为保护模式。通过修改 这个位就可以立即改变CPU的工作模式。![image-20201228222051223](%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/image-20201228222051223.png)

* 不过需要注意的是，一旦CR0寄存器的PE位被修改，CPU就立即按照保护模式去寻址 了，所以这就要求我们必须在进入保护模式之前就在内存里放置好GDT，然后设置好GDTR寄 存器。我们知道实模式下只有1MB的寻址空间，所以GDT就等于被限制在了这里。即便是再 不乐意我们也没有办法，只得委屈就全的先安排在这里。不过进入保护模式之后我们就可 以在4G的空间里设置并修改原来的GDTR了。 OK，现在有了描述符的数组了，也有了“数组指针”（GDTR）了，怎么表示我们要访 问哪个段呢？还记得8086时代的段寄存器吧？不过此时它们改名字了，叫段选择器（段选 择子）。此时的CS等寄存器不再保存段基址了，而是保存其指向段的索引信息，CPU会根据 这些信息在内存中获取到段信息。 地址合成的过程如下图所示：![image-20201228222415850](%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/image-20201228222415850.png)

* 80386之后的保护模式，必原来的CS,ES,SS,DS多了两个寄存器FS,GS
* CS (Code Segment) 代码段
  DS (Data Segment) 数据段
  ES (Extra Segment) 附加段
  SS (Stack Segment) 栈段
* fs,gs是80386起增加的两个bai辅助段寄存器,在这之前只有一个辅助段寄存器ES,增加这两个寄存器是为了减轻ES寄存器的负担,并能更好地配合适用于通用寄存器组的基址和变址寄存器.
* FS：Flag segment标志段寄存器
  GS：Global segment全局段寄存器![image-20201228233428145](%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/image-20201228233428145.png)



## 系统访问地址过程

三、实例（对理解非常有用）

1：访问GDT

![img](%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/726249-20160508134242749-1925360376.jpg)

段描述符在GDT中

当TI=0时表示段描述符在GDT中，如上图所示：

①先从GDTR寄存器中获得GDT基址。

②然后再GDT中以段选择器高13位位置索引值得到段描述符。

③段描述符符包含段的基址、限长、优先级等各种属性，这就得到了段的起始地址（基址），再以基址加上偏移地址yyyyyyyy才得到最后的线性地址。

2：访问LDT

![img](%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/726249-20160508134232234-636264500.jpg)



段描述符在LDT中

当TI=1时表示段描述符在LDT中，如上图所示：

①还是先从GDTR寄存器中获得GDT基址。

②从LDTR寄存器中获取LDT所在段的位置索引(LDTR高13位)。

③以这个位置索引在GDT中得到LDT段描述符从而得到LDT段基址。

④用段选择器高13位位置索引值从LDT段中得到段描述符。

⑤段描述符符包含段的基址、限长、优先级等各种属性，这就得到了段的起始地址（基址），再以基址加上偏移地址yyyyyyyy才得到最后的线性地址。