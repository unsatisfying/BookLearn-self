开机启动（古老的8086处理器）

* 从按下电源键开始，CPU会重置，把第一条指令的地址初始化为` 0xffff0`（现在32位是`0xfffffff0`）（具体实际上是把cs段寄存器初始化为` 0xf000` ,偏移地址寄存器设置为` 0xfff0`,所以真实物理地址就是段寄存器左移四位+偏移就是` 0xffff0`）

*  。 而内存中的地址一部分会映射到外设上，比如一部分映射到显存，一部分映射给硬盘控制器等等。而BIOS的空间会被映射到` 0xc0000`-` 0xfffff`的位置，同时BIOS的程序还占用了内存中开头的一些位置，把中断向量表写在内存开始的一些地方。其中系统BIOS占用了` 0xf0000`-` 0xfffff` 的空间。

* 又因为第一条指令的地址为` 0xffff0`，所以从` 0xffff0`-` 0xfffff`只有16字节的空间代码，但是这个代码肯定不够写，所以这里是一条跳转地址

  ```
  jmp far f000:e05b//意思是跳转到物理地址0xfe05b去运行
  ```

* 地址` 0xfe05b` 部分的代码会检测一些外设的信息，并初始化好硬件，建立中断向量表并填写中断例程，实际上这部分就是写死的。然后最后就是加载启动区。那么何为BIOS启动区。

* BIOS里面就有一张启动设备表，BIOS会按照这 个表里面列出的顺序查找可启动设备。那么怎么知道该设备是否可以启动呢？规则其实很 简单：如果这个存储设备的第一个扇区中512个字节20的最后两个字节是0x55和0xAA，那么 该存储设备就是可启动的。这是一个约定，所以BIOS会对这个列表中的设备逐一检测，只 要有一个设备满足要求，后续的设备将不再测试。 当BIOS找到可启动的设备后，便将该设备的第一个扇区加载到内存的0x7C00地址处， 并且跳转过去执行。（通过in/out指令来把设备中的内容复制到内存）（这个0x7c00是BIOS开发团队设定的），而这段512字节的代码就是所谓的bootloader程序。（早期BIOS团队假设操作系统需要最小内存为32KB，但是又想仅仅留512字节不太好，再多保留一些栈数据，就保留了1KB字节（0x400），所以0x7c00+0x400=0x8000刚好是32KB.

  ```
  
  ; hello-os
  ; TAB=4
  
    ORG  0x7c00   ;程序加载到内存的 0x7c00 这个位置
  
  ;程序主体
  
  entry:
    MOV  AX,0   ;初始化寄存器
    MOV  SS,AX
    MOV  SP,0x7c00
    MOV  DS,AX   ;段寄存器初始化为 0
    MOV  ES,AX
    MOV  SI,msg
  putloop:
    MOV  AL,[SI]
    ADD  SI,1
    CMP  AL,0   ;如果遇到 0 结尾的，就跳出循环不再打印新字符
    JE  fin
    MOV  AH,0x0e   ;指定文字
    MOV  BX,15   ;指定颜色
    INT  0x10   ;调用 BIOS 显示字符函数
    JMP  putloop
  fin:
    HLT
    JMP  fin
  msg:
    DB  0x0a,0x0a  ;换行、换行
    DB  "hello-os"
    DB  0x0a   ;换行
    DB  0    ;0 结尾
  
    RESB 0x7dfe-$   ;填充0到512字节
    DB 0x55, 0xaa   ;可启动设备标识
  ```

  

* 然后启动区中的代码任务主要是加载操作系统，并跳转到操作系统加载处。（）

* ![](./开机启动.assets/bios内存空间.jpg)

# 字符显示

	* 我们知道，对于一个字符的编码通常有输入码、内码和字模码三种。其中字模码定义了 一个字符在屏幕上显示的点阵坐标。通常显卡内置一套关于基本英文字符的显示是很容易 做到的，而内置汉字的显示就较为麻烦。在这篇文档中我们只使用显卡的文本模式，不会 涉及到图形模式的内容。因为一旦使用了图形模式的内容，我们就需要自行定义字符的字 模码了，这很繁琐而且对我们理解操作系统原理的意义不是很大。所以我们只使用显卡的 文本模式进行屏幕显示控制。所有在PC上工作的显卡，在加电初始化之后都会自动初始化 到80*25的文本模式。在这个模式下，屏幕被划分为25行，每行可以显示80个字符，所以 一屏可以显示2000个字符。上图中的0xB8000～0xBFFFF这个地址段便是映射到文本模式的 显存的。当访问这些地址的时候，实际上读写的是显存区域，而显卡会周期性的读取这里 的数据，并且把它们按顺序显示在屏幕上。 那么，按照什么规则显示呢？这就要谈到内码了。内码定义了字符在内存中存储的形 式，而英文编码就是大家所熟知的ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）码了。对应的关系很简单，从0xB8000这个地址开 始，每2个字节表示屏幕上显示的一个字符。从屏幕的第一行开始对应，一行接着一行的对 应下去。而这两个字节的前一个是显示字符的ASCII码，后一个是控制这个字符颜色和属性 的控制信息，这个字节的8个bit位表示不同的含义。每一位的含义如图所示

![image-20201224112514910](./%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/image-20201224112514910.png)

	* 理解了显卡文本模式的原理之后接下来就是对屏幕显示控制编码了。不过显卡除了显 示内容的存储单元之外，还有部分的显示控制单元需要了解。这些显示控制单元被编制在 了独立的I/O空间里，需要用特殊的in/out指令去读写。这里相关的控制寄存器多达300多 个，显然无法一一映射到I/O端口的地址空间。对此工程师们解决方案是，将一个端口作为 内部寄存器的索引：0x3D4，再通过0x3D5端口来设置相应寄存器的值。![image-20201224112729733](./%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/image-20201224112729733.png)

# Debug  printk 和可变参数

* 因为系统底层没有stdin和stdout这种，所以可以通过之前写的screen_write()函数往屏幕上打印字符，但是这里要用到可变参数，即类似printf的可变参数形式。

* ` void printk(const char *format, ...);` 可变参数是通过gcc编译器中内置的va_list来实现的，一些地方也把它定义成宏。

  ```c++
  #define va_list char *
  #define va_start(p, first) (p = (va_list)&first + sizeof(first))//将指针p变成可变参数的第一个参数地址
  #define va_arg(p, next) (*(next*)((p += sizeof(next) ) − sizeof(next)))//将指针p指向下一个参数地址，并返回当前参数的值
  #define va_end(p) (p = (va_list)NULL)//将p定义为NULL
  //调用
  va_start(args,format);
  ```

  

## x86-64函数调用栈和寄存器传递参数

* 以下是64位环境下的，32位环境下所有参数都是通过栈来传递的。

* 在内存中，栈是向下增长的。假设我们写了这么一段程序，

  ```c++
  struct st
  {
          int a;
          int b;
          double c;
  };
  void f(st x,int x1,int x2,int x3,int x4,int x5,int x6,int x7,int x8)
  {
  
  }
  int main()
  {
          int i=1;
          int j=2;
          int k=3;
          st x;
          x.a=1;
          x.b=2;
          x.c=3.0;
          f(x,i,j,k,4,5,6,7,8);
          return 0;
  }
  ```

*  main函数栈帧如下![](%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/%E6%A0%88.jpg)

*  **这里有一个细节，如果被调用的函数是最后一次调用的函数，他的最后一个函数栈帧rsp和rbp是同一个位置，但是还是可以使用rbp以下的空间。**

* 其中栈中数字6，7，8虽然在main函数的栈帧中，但是属于f函数栈帧中可以访问的内容，因为他是参数传递过去的临时变量。

  

* 部分汇编代码如下

  ![image-20201224142822407](%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.assets/image-20201224142822407.png)

## 可变参数传递

由于是可变参数，所以所有参数都是在栈上的，通过va_list即可调取参数列表。